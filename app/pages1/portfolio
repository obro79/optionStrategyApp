import streamlit as st
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.optimize import minimize

# Efficient Frontier Function
def calculate_efficient_frontier(returns, num_portfolios=5000, risk_free_rate=0.01):
    num_assets = returns.shape[1]
    results = np.zeros((3, num_portfolios))
    weights_record = []
    
    for i in range(num_portfolios):
        # Random weights for each asset
        weights = np.random.random(num_assets)
        weights /= np.sum(weights)  # Normalize weights
        weights_record.append(weights)
        
        # Portfolio return and risk
        portfolio_return = np.sum(weights * returns.mean()) * 252  # Annualized return
        portfolio_stddev = np.sqrt(np.dot(weights.T, np.dot(returns.cov() * 252, weights)))  # Annualized risk
        
        # Sharpe ratio
        sharpe_ratio = (portfolio_return - risk_free_rate) / portfolio_stddev
        
        # Store results
        results[0, i] = portfolio_stddev
        results[1, i] = portfolio_return
        results[2, i] = sharpe_ratio
    
    return results, weights_record

# Markowitz Efficient Frontier - Optimization Function
def portfolio_optimization(returns, target_return):
    num_assets = returns.shape[1]
    args = (returns.mean() * 252, returns.cov() * 252)
    
    constraints = ({
        'type': 'eq',
        'fun': lambda x: np.sum(x) - 1
    }, {
        'type': 'eq',
        'fun': lambda x: np.sum(x * returns.mean() * 252) - target_return
    })
    
    bounds = tuple((0, 1) for asset in range(num_assets))
    result = minimize(portfolio_volatility, num_assets * [1. / num_assets,], args=args, method='SLSQP', bounds=bounds, constraints=constraints)
    
    return result

# Portfolio volatility function
def portfolio_volatility(weights, mean_returns, cov_matrix):
    return np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))

# Portfolio Management Page
def portfolio_management_page():
    st.title("Portfolio Management: Efficient Frontier")

    # User inputs for the number of assets and data options
    num_assets = st.sidebar.number_input("Number of Assets", min_value=2, max_value=20, value=5)
    option = st.sidebar.selectbox("Data Source", ["Simulated Data", "Upload Historical Data"])
    
    # Generate returns data (for simulation) or upload file
    if option == "Simulated Data":
        returns = np.random.randn(252, num_assets) / 100  # Simulate daily returns
    else:
        file = st.sidebar.file_uploader("Upload CSV with Returns Data")
        if file:
            returns = pd.read_csv(file)
    
    # Plot Efficient Frontier
    st.subheader("Efficient Frontier")

    if returns is not None:
        results, weights_record = calculate_efficient_frontier(returns)
        
        max_sharpe_idx = np.argmax(results[2])  # Index of max Sharpe ratio
        sdp, rp = results[0, max_sharpe_idx], results[1, max_sharpe_idx]  # Standard deviation and return
        
        # Plotting
        plt.figure(figsize=(10, 6))
        plt.scatter(results[0], results[1], c=results[2], cmap='YlGnBu', marker='o')
        plt.colorbar(label='Sharpe Ratio')
        plt.scatter(sdp, rp, marker='*', color='r', label='Maximum Sharpe Ratio')
        plt.title('Efficient Frontier')
        plt.xlabel('Risk (Std Deviation)')
        plt.ylabel('Return')
        plt.legend(loc='upper left')
        st.pyplot(plt)
        
        # Risk tolerance and desired return level
        st.subheader("Optimization with Desired Return")
        target_return = st.slider("Desired Return Level", min_value=0.0, max_value=1.0, step=0.01)
        optimal_portfolio = portfolio_optimization(returns, target_return)
        
        st.write(f"Optimal Portfolio Weights for Desired Return {target_return}:")
        st.write(pd.DataFrame(optimal_portfolio.x, columns=["Weight"]))
    
    else:
        st.write("Please upload historical data to compute the efficient frontier.")

# Add this function to your main app
